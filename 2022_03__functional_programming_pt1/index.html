<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Welcome to functional programming</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/atom-one-dark-reasonable.css"
    />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h3>Functional Programming</h3>
          <em><small>"A journey begins"</small></em>
          <aside class="notes">
            <ul>
              <li>
                Steven bedanken, Ik sta te popelen om met jullie functioneel
                programmeren te bekijken.
              </li>
              <li>Huge topic</li>
              <li>Maak u klaar om een berg te beklimmen</li>
              <li>Vragen in pm of in de slack community</li>
              <li>Zelf ook nog aan het groeien & bijleren.</li>
            </ul>
          </aside>
        </section>
        <section>
          <h2>My Personal Journey üôã‚Äç‚ôÇÔ∏è</h2>
          <aside class="notes">
            <p>
              Ik hoorde ongeveer een 4-5 jaar geleden iemand spreken van de term
              "Functioneel programeren". Ik had al gehoord van Object oriented
              in het school en wist wel al goed hoe dat werkte maar omdat die
              persoon heel goed was in Javascript wou ik er toch wel meer over
              weten, Ik leerde meer over basisconcepten zoals pure funcions en
              first class functions en dacht, ik kan functioneel programmeren.
              Man was ik verkeerd toen. Dit was ongeveer de periode dat
              underscore js en coffeescript heel populair waren.
            </p>
            <p>
              Er gingen een aantal jaren voorbij en Typescript werd populair en
              ik kwam terug in aanraking met functioneel programeren, maar dit
              keer op een heel ander niveau en er was een hele gap tussen mijn
              kennis en de kennis van mijn team gennoten. Ik moest dingen
              bergijpen zoals Options, Either, Monads, Tuples. etc. etc.
            </p>
          </aside>
        </section>
        <section
          data-background-image="https://camo.githubusercontent.com/8093c2e71744b6ca67a483257fd18b53dca34a4c706f39621f7982f86c5b37b2/687474703a2f2f7777772e766173696e6f762e636f6d2f696d616765732f692d73686f756c642d6361742e6a7067"
          data-background-size="contain"
        >
          <aside class="notes">
            <p>
              Ik begreep ze niet, iemand communiceerde met mij en ik begreep
              niet wat die persoon mij wou vertellen. Die concepten zijn
              belangrijk in functioneel programmeren en worden heel vaak
              gebruikt om te communiceren.
            </p>
            <p>
              We zullen vandaag beginen bij het begin van functioneel
              programmeren. We hebben 30 minuten in 30min kan ik zeker en vast
              niet het hele concept functioneel programmeren uitleggen.
            </p>
          </aside>
        </section>
        <section>
          <h2>Quick Check</h2>
          <aside class="notes">
            <ul>
              <li>
                Wie van jullie past functioneel programmeren dagelijks toe?
              </li>
              <li>
                Wie van jullie kent de term wel maar wil toch heel graag weten
                wat de diepere topics betekenen?
              </li>
              <li>
                Wie van jullie wil code schrijven waarbij de toekomstige lezer
                deze makkelijker kan begrijpen?
              </li>
            </ul>
          </aside>
        </section>
        <section>
          <h2>Series Agenda</h2>
          <aside class="notes">
            <p>
              Vertellen over de groote, waarschijnlijk overheen een paar FE
              syncs. Zal gaan voor vroege en duidelijke aankondiging.
            </p>
          </aside>
        </section>
        <section>
          <ol>
            <li>Definition & Why FP?</li>
            <li class="fragment">Functions</li>
            <li class="fragment">Closure</li>
            <li class="fragment">Composition</li>
            <li class="fragment">Immutability</li>
            <li class="fragment">Recursion</li>
            <li class="fragment">Lists & Data Structures</li>
            <li class="fragment">Async</li>
            <li class="fragment">Where to go after this?</li>
          </ol>
          <aside class="notes">
            <ol>
              <li>
                Eerst en vooral gaan we kijken naar de definitie van fp en
                vooral waarom zouden we het gebruiken? Waar zitten de wins?
              </li>
              <li>
                We gaan het concept function bestuderen op een heel ander niveau
                dan jullie waarschijnlijk gewoon zijn. Iedereen weet wat
                functions zijn maar ik ben vrij zeker dat na deze talk je op een
                heel andere manier naar functions zal kijken.
              </li>
              <li>
                We gaan kijken naar closure en wat het betekend voor functioneel
                programmeren. Ik zou durven zeggen dat het onmogelijk is om fp
                te begrijpen zonder closure te begrijpen.
              </li>
              <li>
                Dan gaan we kijken naar Composition. De manier waarop onze data
                gemapt wordt en doorheen onze applicatie vloeit.
              </li>
              <li>
                Dan gaan we kijken naar Immutability. Hoe gaan we de
                veranderingen van values en state doorheen de tijd beheren?
                Statechanges managen is 1 van de grootste concepten in
                programmeren. Elk programma heeft op een wel bepaald punt in de
                tijd een waarde of state.
              </li>
              <li>
                Recursion is een pretty scary topic. :D te vergelijken met bv
                reguliere expressies. Niemand houd van reguliere expressies.
                Maar op zich ook iets om mee te nemen.
              </li>
              <li>
                DAN! gaan we kijken naar map filter reduce en waar het
                uiteindelijk in de fp puzzel past. Maar omdat we dan gaan
                begrijpen waarom die stukken daar passen gaan we het veel beter
                apprecieren.
              </li>
              <li>
                Uiteindelijk gaan we landen bij Asynchrone code en hoe fp ons
                daar kan helpen. Hoe gaan we functional principles toepassen
                doorheen de tijd?
              </li>
              <li>
                En dan gaan we kijken wat de volgende stappen kunnen zijn. Welk
                libraries bestaan er voor ons? Wat met Typescript, etc, etc?
              </li>
            </ol>
          </aside>
        </section>
        <section>
          <h2>What is FP?</h2>
          <aside class="notes">
            <ul>
              <li>
                Functioneel programmeren is niet: het function keyword gebruiken
                :D lol
              </li>
              <li>
                Functioneel programmeren opent en beschrijft een andere manier
                van denken (Problemen worden anders aangepakt)
              </li>
              <li>
                Functioneel programeren is een concept, een samenhangend geheel
                van modellen en theorien die het uiteindelijk vormen.
              </li>
              <li>
                Ik heb mensen horen zeggen ik kan functioneel programeren: "ik
                gebruik: Map, filter & reduce". Dat is maar een fractie van FP.
              </li>
            </ul>
          </aside>
        </section>
        <section>
          <blockquote>
            In computer science, functional programming is a programming
            <a href="">paradigm</a> where programs are constructed by applying
            and composing functions. It is a
            <a href="">declarative</a> programming paradigm in which function
            definitions are trees of expressions that map values to other
            values, rather than a sequence of
            <a href="">imperative</a>
            statements which update the running state of the program.
          </blockquote>
          <aside class="notes">
            <p>
              Om deze definitie te begrijpen moet je al een aantal dingen weten
            </p>
            <ul>
              <li>1: wat is een paradigma? en</li>
              <li>2: wat is het verschil tussen Declaratief en imperatief?</li>
            </ul>
            <p>
              Een paradigma is een samenhangend stelsel van modellen en
              theorie√´n waarbinnen de werkelijkheid beschreven wordt. Met andere
              woorden: het is de manier waarop wij de werkelijkheid ervaren. En
              iedereen ervaart dit op zijn eigen manier.
            </p>
            <p>Overgang naar waarom functioneel programeren.</p>
          </aside>
        </section>
        <section>
          <h2>Why FP?</h2>
        </section>
        <section>
          <h2>Imperative vs Declarative</h2>
          <aside class="notes">
            <p>
              Dit is 1 van de belangrijkste redenen waarom je zou Functioneel
              Programeren
            </p>
            <p>
              Zoals de definitie zegt: Functioneel programmeren is meer
              Declaratief dan imperatief.
            </p>
          </aside>
        </section>
        <section>
          <h2>Imperative</h2>
          <aside class="notes">
            <p>
              Imperative betekend dat de code vooral gefocussed is op de "Hoe
              lossen we dit probleem op?" De toekomstige lezer van de code moet
              Alle gerelateerde code lezen en ergens uitvoeren mentaal vooraleer
              ze het doel van de code kunnen begrijpen. Ze moeten als het ware
              afleiden van de code wat de code eigenlijk doet.
            </p>
            <p>
              Je zou zeggenn "Op zich niet echt een relevant probleem". :D Wij
              zijn programmeurs dat is wat we doen. Wel eigenlijk is het wel een
              relevant probleem, want...
            </p>
            <p>
              Het dwingt de lezer om iets te doen waar hij eigenlijk geen
              natuurlijke gave voor heeft. Wie kan de code perfect uitvoeren? De
              computer Wie is er niet zo goed in het uitvoeren van code? Onze
              hersenen
            </p>
            <p>
              Dus elke keer dat jij code schrijft dat de lezer dwingt om het uit
              te voeren in zijn hoofd enkel en alleen om ze te begrijpen, is
              code dat moeilijker te begrijpen zal zijn en dus ook code dat
              moeilijker te onderhouden of te verbeteren is.
            </p>
          </aside>
        </section>
        <section>
          <h2>Declarative</h2>
          <aside class="notes">
            <p>
              Wat is declaratief dan? Decalratief staat recht tegenover
              Imperatief en zegt neenee het belangrijke deel is de "Wat is de
              uitkomst" en nog belangrijker de "Waarom doen we dit?".
            </p>
            <p>
              Functioneel programmeren is op zichzelf meer declaratief
              georienteerd. Maar op zich is ook alles relatief te bekijken.
            </p>
            <p>
              Niets is echt absoluut hier en zegt ok functioneel programmeren is
              declaratief en al de rest is imperatief, zo werkt het niet. Het is
              gebasseerd op de perceptie van de lezer of de schrijver. ASEMBLY.
            </p>
            <p>
              Hoe meer we de lezer van onze code zijn focus kunnen verschuiven:
              weg van imperatieve, naar het declaratieve, hoe makkelijker het
              zal zijn voor hem om de code te begrijpen. En dat geld niet enkel
              wanneer iemand onze code leest. Dit geld ook voor onszelf in de
              toekomst.
            </p>
          </aside>
        </section>
        <section>
          <h2>Provable</h2>
          <aside class="notes">
            <p>
              Nog een interessante reden waarom functioneel programmeren die
              meer uit de hoek van de mathematici komt is het feit dat het
              <strong>bewijsbaar</strong> is. Functioneel programmeren ook al
              lijkt op een reeks functies die elkaar aanroepen, is het eigenlijk
              <strong>pure wiskunde</strong>.
            </p>
            <p>
              Ik ben vrij zeker dat er nu wel ergens een belletje gaat rinkelen
              of dat er nu wel iemand is die terugdenkt aan de lessen wiskunde
              van in het middelbaar. Waar we vergelijkingen moesten mathematisch
              bewijzen. En waar er een manier werd gezocht om effectief aan te
              tonen waarom 1 + 1 = 2 in de wiskunde. Geloof het of niet maar die
              vergelijking is eigenlijk moeilijker te bewijzen dan je denkt.
            </p>
            <p>
              Maar dat is niet het doel hier. Wij weten dat iemand ooit (1 of
              andere wiskundige) dat bewijs voor ons heeft afgeleverd en daarom
              is dat waar. Het kan niet in twijfel worden getrokken.
            </p>
            <p>
              Dus uiteindelijk als ik u vertel dat functioneel programmeren
              gebaseerd is op pure wiskunde (1+1) dan is dat het einde van het
              verhaal. De wiskunde is bewezen en is correct.
            </p>
            <p>
              Functioneel programmeren belooft ons wanneer we bepaalde
              programeer principes toepassen dat het gebaseerd is op echte
              wiskundige berekeningen. En ook al begrijp ik de wiskunde niet,
              kan ik ervan uitgaan dat het bewezen is door iemand die slimmer is
              dan ik.
            </p>
            <p>
              En dat is uiteindelijk het soort code dat je wil in je programma.
              Als ik die code gebruik dan weet ik wat ik kan verwachten en dan
              weet ik dat ze elke keer werkt. 1 + 1 = 2
            </p>
            <p>
              Nu kan ik mezelf focussen op belangrijkere code in mijn
              applicatie, <strong>business logica en domein locgica</strong>.
              Dit is de code waar ik mijn tijd aan wil spenderen.
            </p>
          </aside>
        </section>
        <section>
          <h2>less to read</h2>
          <aside class="notes">
            <p>
              Wat is de beste code? De beste code is code die niet bestaad :D of
              die niet moet gelezen worden. Beetje een vreemde uitspraak maar
              laat het mij even uitleggen.
            </p>
            <p>
              Stel er is een codebase die 10.000 lijnen groot is. Wat als er van
              die code 9.900 regels gebaseerd zijn op mathematische principes
              waar ik niet moet aan twjifelen en maar 100 regels business logic
              code waar ik mijn hele dag aan toewijd.
            </p>
            <p>
              Zou deze codebase makkelijker onderhoudbaar zijn? Zou ik sneller
              stukken vinden en zou ik makkelijker bugs oplossen? Als ik de
              oppervlakte verklein van hetgeen waar ik me op zou moeten
              focussen?
            </p>
          </aside>
        </section>
        <section
          data-background-image="https://memegenerator.net/img/instances/61907223.jpg"
          data-background-size="contain"
        ></section>
        <section>
          <h2>Functions</h2>
          <aside class="notes">
            <p>
              Dus functions, spreken we enkel over het function keyword? Of
              spreken we over een dieper concept? Wat is de definitie van een
              functie? Vandaag gaan we de definitie van een functie telkens
              verfijnen.
            </p>
            <p>Laat ons even een voorbeeld nemen</p>
          </aside>
        </section>
        <section>
          <h3>What is a function?</h3>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="|1-4|5-8|">
                function addNumbers (x = 0, y = 0, z = 0, w = 0) {
                  var total = x + y + z + w;
                  console.log(total);
                }

                function extraNumbers (x = 2, ...args) {
                  return addNumbers(x, 40, ...args);
                }

                extraNumbers();           // 42
                extraNumbers(3, 8, 11);   // 62
            </code>
          </pre>
          <aside class="notes">
            <p>
              <strong>[SPACE]</strong> Hier zien we een functie addNumbers, we
              krijgen xyz en w binnen in de functie we gaan deze optellen en dan
              gaan we het totaal naar de console printen.
            </p>
            <p>
              <strong>[SPACE]</strong> Daarnaast hebben we extraNumbers die
              addNumbers blijkbaar aanroept en die voegt dan wat extra waarden
              toe.
            </p>
            <p>De meest krieteke vraag hier is, zijn dit een functies?</p>
            <p>
              Laat ons even kijken naar addNumbers: we krijgen wel input values
              binnen. en we doen er wel degelijk iets mee, we maken een totaal
              en we printen alles uit. Deze functie doet wel degelijk iets. Maar
              is dat genoeg? Niet echt. De lat ligt horen om een functie te
              zijn.
            </p>
            <p>
              Maar wat zijn deze functies dan? De beste term dat je kan
              gebruiken om deze twee functies te beschrijven is procedure.
            </p>
            <p>
              Een procedure is een collectie van opperaties. We gebruiken
              allemaal procedures want we moeten allemaal dingen doen in onze
              programmas. Dus het functie keyword gebruiken is niet genoeg om
              een functie te maken wel genoeg om een procedure te maken.
            </p>
            <p>
              Procedures kunnen perfect dingen doen en dingen terugkeren en er
              zijn veel voordelen aan procedures. Maar wat is nu het verschil
              tussen een procedure en een function.
            </p>
            <p>
              <strong>We zullen onze definitie beginnen</strong> bij het feit
              dat een functie niet enkel een input moet hebben maar ook een
              output. Niet enkel printen naar de console, een echte return
              value. Dat is het eerste deel van de puzzel.
            </p>
            <p>
              is extraNumbers een pure functie? Het neemt inputs en returnt een
              output. De meesten hier weten dat een functie automatisch in js
              undefined weergeeft. Dus uiteindelijk geeft addNumbers wel
              undefined terug.
            </p>
            <p>
              Wel, de definitie breid zich uit naar het feit dat functies enkel
              andere functies kunnen aanroepen. Dus omdat addNumbers een
              procedure is is extraNumbers dat automatisch ook.
            </p>
          </aside>
        </section>
        <section>
          <h3>Functions vs Procedures</h3>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="|5|2">
                function tuple (x, y) {
                  return [x + 1, y - 1];
                }

                var [a, b] = tuple(...[5, 10]);

                console.log(a);   // 6
                console.log(b);   // 9
            </code>
          </pre>
          <aside class="notes">
            <p>
              Wat kunnen we hier zeggen? Tupple is een eigenlijk gewoon een
              array van elementen die aan elkaar gelinkt zijn, vooral gebruikt
              in datastructuren en talen zoals python, elm en erlang. Js heeft
              geen syntactic sugar voor tupples.
            </p>
            <p>
              <strong>[SPACE]</strong> Hier op lijn 5 maken we de lezer van de
              code wel duidelijk dat hetgeen wat uit de array komt belangrijker
              is dan de array zelf. De array op zich is onbelangrijk. Merk hier
              ook vooral op dat we uiteindelijk achterblijven met 2 outputs ipv
              1.
            </p>
            <p>
              Dus de definitie breid uit en zegt: een funcie kan meerder inputs
              hebben maar eigenlijk ook meerder outputs.
            </p>
            <p>
              <strong>[SPACE]</strong> <strong>Maar er is nog meer</strong>, wat
              als we op lijn 2 gewoon return 40 zouden zetten. We geven inputs
              en we krijgen een output. Wel dat is op zich dan ook weer geen
              "echte" functie meer. En om de echte geest van een functie te
              begrijpen moeten we toch terugkeren naar de pure wiskunde
            </p>
          </aside>
        </section>
        <section>
          <p>
            <strong>f(x) = 2x<sup>3</sup> + 3</strong>
          </p>
          <aside class="notes">
            <p>
              En als we terugkeren naar pure wiskunde dan keren we terug naar
              wat wij kende in het middelbaar als formules. Een formule of een
              vergelijking. En ik weet nog goed bij mij betekende dat niet veel
              tot als we die grafische rekenmachines erbij pakte. Want
              uiteindelijk waren het allemaal random nummers die we terugkregen
              in het begin. 1 gaf een 5 en 2 gaf 11. En uiteindelijk als we al
              die waarden gingen verbinden met elkaar dan kregen we onze
              tekening.
            </p>
          </aside>
        </section>
        <section>
          <img src="img/para.png" alt="parabool" width="300px" />
          <pre class="fragment" data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers>
                function f(x) {
                  return 2 * Math.pow(x, 2) + 3;
                }
            </code>
          </pre>
          <aside class="notes">
            <p>
              Anders gezegd, dus als we een x coordinaat ingeven krijgen we een
              output y coordinaat. En wanneer we de input en de output samen
              voegen, dan kunnen we hun betekenis interpreteren als een
              parabool.
            </p>
            <p>Dus! Wat is een functie?</p>
          </aside>
        </section>
        <section>
          <h3>
            A function is the semantic <a href="">relationship</a> between the
            <a href="">input</a>
            and the computed <a href="">output</a>
          </h3>
          <aside class="notes">
            <p>
              Het doel hier is om relaties te creeren die vanzelfsprekend zijn
              voor de lezer van onze code
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers>
                function shippingRate (size, weight, speed) {
                  return ((size + 1) * weight) + speed;
                }
            </code>
          </pre>
          <aside class="notes">
            <p>
              Hier als we een functie maken shippingRate, dan verteld de naam
              van de functie mij iets over de relatie tussen de input waarden en
              de output. Als ik size, weight en speed ingeef krijg ik een
              shippingRate terug. Daarvoor dient het.
            </p>
            <p>
              We hebben veel "functies" in onze apps, aka procedures.Sommige
              duizenden.
            </p>
            <p>
              Bij hoeveel functies in onze apps kunnen we zien wat de relatie is
              tussen input en output?
            </p>
            <p>
              Hoeveel functies hebben uberhaupt outputs? Waarschijnlijk niet
              veel.
            </p>
          </aside>
        </section>
        <section>
          <h3>üòé</h3>
          <aside class="notes">
            <p>
              Dus aan ons om een soort bril op te zetten en te zien in onze apps
              waar de "echte" functies zitten en hoe we ze kunnen isoleren.
            </p>
          </aside>
        </section>
        <section>
          <h2>Side effects</h2>
          <aside class="notes">
            <p>
              Ben zeker dat velen de term...side effects al gehoord hebben of
              kennen.
            </p>
            <p>
              Dus in functioneel programeren willen we functies zonder side
              effects. Maar wat betekend dat?
            </p>
          </aside>
        </section>
        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="|5-8">
                function shippingRate () {
                  rate = ((size + 1) * weight) + speed;
                }
                
                var rate;
                var size = 12; var weight = 4; var speed = 5;
                shippingRate();
                rate;   // 57

                size = 8; speed = 6;
                shippingRate();
                rate;   // 42

            </code>
          </pre>
          <aside class="notes">
            <p>
              Als we naar dit programma kijken dan zijn er een aantal dingen die
              je kan opmerken. 1. shippingRate heeft geen parrameters 2.
              shippingRate heeft geen return keyword
            </p>
            <p>
              Maar we zien wel dat de functie iets doet met wat waarden. en
              effectief een berekening maakt die een rate berekend.
            </p>
            <p>
              <strong>[SPACE]</strong> Op lijn 5 en 6 zetten we de inputs wel
              op, we roepen shippingRate aan op lijn 7 en op lijn 8 hebben we
              een legitte shippingRate. Deze code werkt perfect.
            </p>
            <p>
              Deze code is eigenlijk zoals veel van onze code in onze apps. We
              gebruiken stuff buiten de functie en we beinvloeden andere dingen
              ergens anders en uitendelijk vervolledigen we ons einddoel om een
              shippingRate te berekenen. Wat perfect ok is, het is alleen niet
              functioneel.
            </p>
            <p>
              <strong>De definitie breid nogmaals uit.</strong> In theorie
              hebben we hier inputs en outputs en is er een relatie die
              beschreven wordt als een functie. Maar de outputs en inputs zijn
              indirect.
            </p>
            <p>
              <strong
                >ALS de inputs of de outputs indirect zijn, spreken we niet over
                een echte functie.</strong
              >
            </p>
            <p>
              Dus uitendelijk als we side effects bedoelen, bedoelen we
              indirecte input of indirecte outputs of beiden.
            </p>
            <p>
              Dit zijn side effect, en we willen ze zo veel mogelijk vermeiden.
              We krijgen de voordelen niet van pure functies als we side effects
              hebben. We krijgen niet de provability & de security waarbij we
              weten dat dit ding 100% werkt.
            </p>
            <p>Niet alleen jij maar ook de lezer krijgt de voordelen niet.</p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers>
                function shippingRate (size, weight, speed) {
                  return ((size + 1) * weight) + speed;
                }
                
                var rate;
                rate = shippingRate(12, 4, 5)  // 57
                rate = shippingRate(8, 4, 6)   // 42

            </code>
          </pre>
          <aside class="notes">
            <p>
              Dit is een voorbeeld van directe input en die sematisch gerelateed
              is aan directe output
            </p>
            <p>
              Hier is wel iets zeer interessant op te merken hier: Om de
              definitie van een functie te hebben. Heb je een
              <strong>function invocatie</strong>
              nodig. De definitie van de functie is op zich minder belanrijk dan
              de functie invocatie. Het belangrijke deel hier is de functie
              invocatie.
            </p>
          </aside>
        </section>
        <section>
          <h3>Side effects</h3>
          <ul>
            <li>Variables outside of the function</li>
            <li class="fragment">I / 0 (console, files, etc.)</li>
            <li class="fragment">db storage</li>
            <li class="fragment">Network Calls</li>
            <li class="fragment">DOM</li>
            <li class="fragment">Timestamps, Random Numbers</li>
            <li class="fragment">...</li>
          </ul>
          <aside class="notes">
            <p>
              Wat zijn nu side effects? En hoe kunnen we ze identificeren? We
              zagen er 1 maar er zijn er zeker meer.
            </p>
            <p>ALLES OVERLOPEN</p>
            <p>
              Op zich zeggen we in functioneel programmeren avoid side effects.
              Maar wat daar eigenlijk gezegd wordt is minimize side effects.
            </p>
            <p>
              Elk programma heeft side effects. Dus side effects zijn niet
              noodzakelijk slecht. Wat ze wel doen zijn de voordelen van
              functioneel programeren wegnemen.
            </p>
            <p>
              Wat willen we doen met side effects. We willen ze heel
              intentioneel vermeiden of uitvergroten in onze applicaties want
              daar zitten de bugs. Daar zitten de meeste problemen.
            </p>
          </aside>
        </section>
        <section>
          <h3>Pure Functions</h3>
          <aside class="notes">
            <p>
              Dus wat is een pure functie? Een pure functie is een functie die
              al zijn inputs direct ontvangt en al zijn outputs direct doorgeeft
              en de functie heeft geen side effect. Maar onthoud hier dat het
              meer over de call gaat dan over de definitie. Dus we willen gaan
              voor pure function calls.
            </p>
          </aside>
        </section>
        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers>
                // pure
                function addTwo (x, y) {
                  return x + y;
                }

                // impure 
                function addAnother (x, y) {
                  return addTwo(x, y) + z;
                }
            </code>
          </pre>
          <aside class="notes">
            <p>
              Dus addTwo is pure, maar addAnother hier gebruikt z als een
              indirecte input, dus theoretisch gezien is deze functie impure.
            </p>
            <p>
              Daar willen we in onze programmas naar kijken, waar zitten de
              indirecte inputs in onze functies en invalideren ze of de functie
              zich puur zal gedragen of niet. Op zich is het in praktijk
              ingewikkelder. De code kan er als volgt uitzien
            </p>
          </aside>
        </section>
        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="|8|11|1">
                const z = 1

                function addTwo (x, y) {
                  return x + y;
                }

                function addAnother (x, y) {
                  return addTwo(x, y) + z;
                }

                addAnother(20, 21);   // 42
            </code>
          </pre>
          <aside class="notes">
            <p>
              De code kan een variable hebben in de outer scope of vanuit een
              import statement. In dit geval is het de z variable.
            </p>
            <p>
              <strong>[SPACE]</strong> Wat als er nu stond ipv + z, + 1 op lijn
              8
            </p>
            <p>Iedereen zou zeggen, geen probleem. Dat is een pure functie</p>
            <p>
              Is de variabele z hier echt een invalidatie van de pure functie of
              is z gewoon een semantische placeholder die 1 bevat?
            </p>
            <p>
              <strong>[SPACE]</strong> addAnother veroorzaakt geen side effects,
              en gebruikt geen side effects buiten die z constante. En dat is
              uiteindelijk ook beschouwd als pure. Lijn 11 is nog steeds een
              pure function call.
            </p>
            <p>
              <strong>[SPACE]</strong> En misschien denken we hier van ok dat
              klopt omdat we op lijn 1 const gebruiken
            </p>
          </aside>
        </section>
        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="1||8|1-10|11,7-9">
                var z = 1

                function addTwo (x, y) {
                  return x + y;
                }

                function addAnother (x, y) {
                  return addTwo(x, y) + z;
                }

                addAnother(20, 21);   // 42
            </code>
          </pre>
          <aside class="notes">
            <p>Wat als we het var keyword gevruiken? Is het nu nog pure?</p>
            <p>
              Is de keuze tussen var en const hier wat de leesbaarhed bepaald
              van het programma? Ik zou zeggen nee. En ik ga ook de reden zegen
              waarom niet en dit is belangrijk voor de rest van onze talk hier.
            </p>
            <p>
              Wat als ik u een vraag stel over een programma? Maar ik liet u
              maar een deel zien van het programma? Wat kun je dan antwoorden?
              Je zou eender wat kunnen zeggen. Dus het is niet echt nuttig om
              een programma te bespreken tenzij we het in zijn geheel kunnen
              zien en bespreken.
            </p>
            <p>
              Dus vanaf nu assumeren we dat we heel het programma telkens zien.
              En daaruit volgt dan de vraag: wordt in dit programma z opnieuw
              toegekend aan een andere waarde? Nee. Dus deze var gedraagt zich
              in dit programma eigenlijk als een const.
            </p>
            <p>
              De belangrijkste vraag is dus: wordt de variabele gereassigned? en
              niet: kan de variabele gereassigned worden. EN! Nog belangrijker,
              is het vanzelfsprekend voor de lezer of deze varabele gereassigned
              wordt ja of neen?
            </p>
            <p>
              addAnother gedraagt zich pure omdat z niet gereassigned wordt.
            </p>
            <p>
              Maar wacht: op lijn 8 hebben we NOG! een variabele die reassigned
              kan worden. addTwo is een functie die op lijn 3 gemaakt wordt maar
              deze kan makkelijk op lijn 6 gereassigned worden. Maar in dit
              programma kunnen we zien dat addTwo niet wordt gereassigned, dus
              het gedrach is nog steeds pure.
            </p>
            <p>
              Wat dus belangrijk is voor de auteur van de code. Is om duidelijk
              te maken dat de gebruikte functie addTwo (in dit geval) gebruikt
              zal worden als een const en dat deze niet kan gereassigned worden.
              Dat is het doel.
            </p>
            <p>
              <strong>[SPACE]</strong> MAAR WAAROM? We willen de lezer van de
              code minder zorgen geven. In dit programma moet de lezer effectief
              gaan kijken op lijn 3, 4 en 5 wat addTwo doet en moet die gaan
              kijen eigenlijk over heel het programma of er geen reassignment
              gebeurd van varable z. Ze moeten het hele programma mentaal
              uitvoeren. Van lijn 1 tot lijn 11 om het te begrijpen.
            </p>
            <p>
              Als ik zie als lezer in de code dat addAnother volledig pure is en
              ik moet nergens anders gaan kijken. Dan kan ik lijn 11 veilig in
              <strong>[SPACE]</strong> isolatie uitvoeren mentaal om het
              programma te begrijpen.
            </p>
          </aside>
        </section>
        <section>
          <h3>Reducing surface area</h3>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="|1|2|3|7|">
                function addAnother (z) {
                  return function addTwo(x, y) {
                    return x + y + z;
                  }
                }

                addAnother(1)(20, 21);  // 42
            </code>
          </pre>
          <aside class="notes">
            <p>
              Dit is een heel ander voorbeeld als daarnet. Sommigen herkenen
              meteen het patroon. Je hebt waarschijnlijk al gezien dat functies
              als waardes kunnen worden terug gegeven.
            </p>
            <p>
              <strong>[SPACE]</strong> Dus we hebben een functie addAnother die
              en z parameter aanvaard. Het is geen const in de global scope, het
              is een parameter die in gegeven wordt als eerste.
            </p>
            <p>
              <strong>[SPACE]</strong> Op lijn 2 returnen we dan een functie die
              uiteindelijk op lijn <strong>[SPACE]</strong> 3 ook z gebruikt.
            </p>
            <p>
              <strong>[SPACE]</strong> Dus op lijn 7 krijgen we een dubbele
              function invocatie.
            </p>
            <p>
              Wat interessant is in deze code is dat deze code tegenover het
              vorige voorbeeld. Een kleiner oppervlak heeft waar wij ons zorgen
              hoeven te maken dat z opnieuw kan gereassigned worden. Als wij
              willen controleren is z effectief een const. dan zijn er maar 2
              lijnen waar we rekening moeten mee houden. lijn 1,5 en lijn 2,5
            </p>
            <p>
              Het zijn de enige 2 lijnen in het hele programma dat z opnieuw
              kunnen reassignen
            </p>
            <p>
              Als een gevolg van dat kleiner oppervlak kunnen we zeggen dat we
              de leesbaarheid verhogen. We verhogen de zelfzekerheid voor de
              lezer van onze code, wanneer hij z als 1 ingeeft dan is hij
              zekerder dat dat 1 blijft
            </p>
          </aside>
        </section>
        <section>
          <h3>Same input, same output</h3>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers>
                function getId(obj) {
                  return obj.id;
                }
            </code>
          </pre>
          <aside class="notes">
            <p>Wat kunnen we zeggen over deze functie?</p>
            <p>Eerst even laten inzinken</p>
            <p>
              Wat Als ik getId telkens opnieuw zou aanroepen met hetzelfde
              object. Zal ik dan dezelfde waarde krijgen? Hoe zeker kan je deze
              functie voorspellen?
            </p>
            <p>
              De belangrijke vraag om hier te stellen is: Wordt dit object
              ergens op een bepaald punt gemuteerd? Stel dat het antwoord nee
              is. Dat je alle plaatsen kan zien waar getId wordt aangeroepen.
              Zou je dan zeker zijn dat deze functie pure is?
            </p>
          </aside>
        </section>
        <section>
          <h3>Same input, same output</h3>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers>
                function getId(obj) {
                  return obj.id;
                }

                getId({
                  get id() {
                    return Math.random();
                  }
                })
            </code>
          </pre>
          <aside class="notes">
            <p>
              Wat als ik meer van het programma toon, wat als dat object een
              getter heeft ipv een property en wat als die getter random nummers
              genereert?
            </p>
            <p>Ineens is ons level of confidence wel helemaal weg nu.</p>
            <p>
              Het is belangrijk om het hele programma te zien of beter! Alle
              relevante delen van het programma.
            </p>
            <p>
              Pure functie invocaties werken in isolatie. Anders gezegd: wanneer
              we telkens dezelfde input geven, gaan we dezelfde output krijgen.
            </p>
            <p>
              Nog een kleine component van onze definitie van een pure functie.
              Elke keer we een pure functie aanroepen met dezelfde input, dan
              krijgen we telkens dezelfde output.
            </p>
          </aside>
        </section>
        <section>
          <h3>How to make it pure?</h3>
          <aside class="notes">
            <p>
              Wat zijn de opties als we een inpure functie hebben? Wat kunnen we
              doen? 1 optie is om het inpure te laten, we hebben nu eenmaal side
              effects. Ze moeten gebeuren en zo is dat.
            </p>
            <p>
              We kunnen er zeker expliciet over zijn. We kunnen het procedure
              zodanig noemen zodat het duidelijk is dat het naar de database
              gaan schrijven of een api call gaan uitvoeren.
            </p>
            <p>
              Een commentje? Thar be dragons...side effects beware, of een
              sideEffects.js file?
            </p>
            <p>
              De reden waarom we expliciet willen zijn is omdat we het zo
              makkeiljker maken om de code te onderhouden.
            </p>
          </aside>
        </section>
        <section>
          <h3>Extracting impurity</h3>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="|12|8-9|3|">
                function newComment(userId, comment) {
                  var record = {
                    id: generateUID(),
                    user: userId,
                    text: comment
                  };
                  
                  var elem = commentElement(record);
                  commentsList.appendChild(elem);
                }

                newComment(42, "This is my comment!");
            </code>
          </pre>

          <aside class="notes">
            <p>
              Kunnen we een stuk herschikken zodanig dat een deel van de functie
              pure wordt en een ander deel de side effects heeft?
            </p>
            <p>
              We brengen het side effect naar de buitenlaag en we houden de pure
              functionaliteit in de core van de app
            </p>
            <p>
              <strong>[SPACE]</strong> Lijn 12 is een inpure function call omdat
              we op <strong>[SPACE]</strong> lijn 8 en 9 een side effect hebben.
            </p>
            <p>
              <strong>[SPACE]</strong> Misschien heb je ook op lijn 3 een anders
              side effect gezien?
            </p>
            <p>
              <strong>[SPACE]</strong> Wat als we van deze code zoiets kunnen
              maken?
            </p>
          </aside>
        </section>
        <section>
          <h3>Extracting impurity</h3>
          <pre data-id="code-animation" style="font-size: 0.9rem">
            <code class="language-js" data-trim data-line-numbers="|1-8|10,16|">
                function newComment(userId, commentId, comment) {
                  var record = {
                    id: commentId,
                    userId,
                    text: comment
                  };
                  return buildCommentElement(record);
                }

                var commentId = generateUID();
                var elem = newComment(
                  42,
                  commentId,
                  "This is my comment!"
                );
                commentsList.appendChild(elem);
            </code>
          </pre>

          <aside class="notes">
            <p>
              <strong>[SPACE]</strong> We hebben hier geen procedure newComment
              maar een functie newComment. De enige job van die functie is om
              een nieuwe comment te maken.
            </p>
            <p>
              <strong>[SPACE]</strong> De side effects in dit programma zitten
              op lijn 10 en lijn 16
            </p>
            <p>
              De side effets bestaan nog, maar zitten in de buitenschil van het
              programma.
            </p>
          </aside>
        </section>
        <section>
          <h3>Containing impurity</h3>
          <pre data-id="code-animation" style="font-size: 0.8rem">
            <code class="language-js" data-trim data-line-numbers="|11|7,11">
                var someAPI = {
                  threshold: 13,
                  isBelowThreshold: function(x) {
                    return x <= SomeAPI.threshold;
                  }
                }
                var numbers  = [];
                
                function insertSortedDesc(v) {
                  SomeAPI.threshold = v;
                  var idx = numbers.findIndex(SomeAPI.isBelowThreshold);
                  
                  if (idx == -1) {
                    idx = numbers.length;
                  }
                  numbers.splice(idx, 0, v);
                }

                insertSortedDesc(3);
                insertSortedDesc(5);
                insertSortedDesc(1);
                insertSortedDesc(4);
                insertSortedDesc(2);
                numbers;    // [5, 4, 3, 2, 1]
            </code>
          </pre>

          <aside class="notes">
            <p>
              Als we de impurity niet kunnen extracten, dan hebben we nog een
              manier om een functie pure te maken. Dat is door ze te containen
              met een andere functie.
            </p>
            <p>
              Wat bedoelen we hier exact mee? Containen. En wat zijn de
              voordelen. Wat als we een side effect kunnen isoleren in een
              functie die maar 5 lijnen groot code is ipv dat we een side effect
              hebben in de hele global scope. Dat is wat we bedoelen met
              containing the impurity
            </p>
            <p>
              Als we naar deze code kijken dan zien we een someAPI object met
              wat properties en een methode isBelowThreshold. Wat belangrijk is
              daar op lijn 11 is dat we die methode gebruiken daar op lijn 11.
              <strong>[SPACE]</strong> SOme api kan een framework of een node
              module zijn in dit voorbeeld.
            </p>
            <p>
              <strong>[SPACE]</strong> Wat doe ik als ik de numbers array niet
              will vervuilen in de global scopen en ik wil die SomeAPI niet
              gebruiken? Laten we de functie insertSortedDesc wrappen met een
              andere functie.
            </p>
          </aside>
        </section>
        <section>
          <h3>Containing impurity</h3>
          <pre data-id="code-animation" style="font-size: 0.8rem">
            <code class="language-js" data-trim data-line-numbers="|7,10,21|25-29|9-23|15,16">
                var someAPI = {
                  threshold: 13,
                  isBelowThreshold: function(x) {
                    return x <= SomeAPI.threshold;
                  }
                }
                var numbers  = [];

                function getSortedNums(nums, v) {
                  var numbers = num.slice();
                  insertSortedDesc(v);
                  return numbers;

                  function insertSortedDesc(v) {
                    SomeAPI.threshold = v;
                    var idx = numbers.findIndex(SomeAPI.isBelowThreshold);

                    if (idx == -1) {
                      idx = numbers.length;
                    }
                    numbers.splice(idx, 0, v);
                  }
                }

                numbers = insertSortedDesc(numbers, 3);
                numbers = insertSortedDesc(numbers, 5);
                numbers = insertSortedDesc(numbers, 1);
                numbers = insertSortedDesc(numbers, 4);
                numbers = insertSortedDesc(numbers, 2);
                numbers;    // [5, 4, 3, 2, 1]
            </code>
          </pre>

          <aside class="notes">
            <p>
              Hier hebben we een functie getSortedNums rond de functie
              insertSortedDesc gezet. Merk op hier dat we nog steeds de globale
              var numbers hebben op lijn 7.<strong>[SPACE]</strong> Maar merk
              ook op dat er nieuwe array is op lijn 10. Wanneer lijn 21 nu de
              array aanpast gaat die de array op lijn 10 aanpassen en niet die
              op lijn 7.
            </p>
            <p>
              <strong>[SPACE]</strong>Op lijnen 25 tot 29 geven we de global
              scope numbers array door aan de functie getSortedNums en daar
              maken we een copy op lijn 10 waar we de bewerking op doen.
            </p>
            <p>
              Wat hebben we hier nu exact gedaan. We hebben hier het side effect
              van de array aan te passen gereduceerd tot de lijnen
              <strong>[SPACE]</strong> ipv de globale scope van heel het
              programma
            </p>
            <p>
              We zitten wel nog steeds met impurity hier op
              <strong>[SPACE]</strong> lijn 15 en dan op lijn 16. Op zich kunnen
              we hier niet gaan wrappen want het komt uit een framework. Is er
              een andere manier dat we deze impure lijn eruit kriigen? Er is nog
              een techniek maar het is wel lelijker dan dit. Maar het is beter
              dan niets. Ipv de functie te wrappen kunnen we kijken naar een
              volgende techniek en dat is een adapter functie naast onze functie
              zetten.
            </p>
          </aside>
        </section>
        <section>
          <h3>Adaptor function</h3>
          <pre data-id="code-animation" style="font-size: 0.8rem">
            <code class="language-js" data-trim data-line-numbers="|19-26|20|21|22|23|24|">
                var someAPI = {
                  threshold: 13,
                  isBelowThreshold: function(x) {
                    return x <= SomeAPI.threshold;
                  }
                }
                var numbers  = [];

                function insertSortedDesc(v) {
                  SomeAPI.threshold = v;
                  var idx = numbers.findIndex(SomeAPI.isBelowThreshold);

                  if (idx == -1) {
                    idx = numbers.length;
                  }
                  numbers.splice(idx, 0, v);
                }

                function getSortedNums(nums, v) {
                  var [origNumbers, origThreshold] = [numbers, SomeAPI.threshold]
                  numbers = nums.slice();
                  insertSortedDesc(v);
                  nums = numbers;
                  [numbers, SomeAPI.threshold] = [origNumbers, origThreshold];
                  return nums;
                }

                numbers = insertSortedDesc(numbers, 3);
                numbers = insertSortedDesc(numbers, 5);
                numbers = insertSortedDesc(numbers, 1);
                numbers = insertSortedDesc(numbers, 4);
                numbers = insertSortedDesc(numbers, 2);
                numbers;    // [5, 4, 3, 2, 1]
            </code>
          </pre>

          <aside class="notes">
            <p>
              Merk op dat we nu terug dichter staan tegen het eerste voorbeeld,
              we hebben een insertSortedDescription en ipv een functie errond
              hebben we nu een adapter functie die naast defunctie staat.
              <strong>[SPACE]</strong>
            </p>
            <p>
              <strong>[SPACE]</strong>Wat het belangrijkste is hier is dat we op
              lijn 20 eerst een copy maken van de huidige state die gaat worden
              aangepast.
            </p>
            <p>
              <strong>[SPACE]</strong>Daarna op lijn 21 gaan we de omgeving
              opzetten door de aangegeven array te copieren.
            </p>
            <p>
              <strong>[SPACE]</strong>Daarna op lijn 22 roepen we ons side
              effects aan insertSortedDesc.
            </p>
            <p>
              <strong>[SPACE]</strong>Op lijn 23 vangen we de verandering op in
              de aangegeven nums parameter.
            </p>
            <p>
              <strong>[SPACE]</strong>En dan het belangrijkste stuk van de code
              op lijn 24 zetten we de state terug naar wat die initiel was. en
              op lijn 25 geven we nums terug
            </p>
            <p>
              <strong>[SPACE]</strong> Dit is heel bruut, het is op zich geen
              prachtige code en het zal snel complexer worden als we bv dingen
              in de dom gaan beginnen bijcoderen.
            </p>
            <p>
              Het belangrijkste wat we hier uiteindelijk gedaan hebben is dat nu
              lijn 28 nu wel uitgevoerd wordt kan worden als een pure function.
              Alle condities kunnen wordden afgevinkt. Het neemt directe inputs
              en geeft directe outputs, er zijn geen state changes achteraf
              gezien. En we hebben niet gerust op de state voor de functie
              invokatie
            </p>
          </aside>
        </section>

        <section>
          <h3><a href="">Last resort</a>: at least make it obvious</h3>
          <aside class="notes">
            <p>
              Als we niet kunnen extracten, als we niet kunnen containen en als
              we geen adapter functie kunnen schrijven. Dan blijven we zitten
              met ons side effect. Maar maak het op dat moment dat op zijn minst
              extreem duidelijk dat daar problemen zitten.
            </p>
          </aside>
        </section>
        <section>
          <h3>
            <a
              href="https://gitlab.mediahuisgroup.com/robbie.bardijn/functional-programming"
              target="_blank"
              >Exercises</a
            >
          </h3>
          <aside class="notes">
            <p>
              Voor mensen die hunzelf is willen testen. Heb ik 2 oefeningskes op
              deze repo gezet.
            </p>
            <p>Oefeningen kort uitleggen</p>
            <p>We zullen deze oefening kort efkes herevalueren volgende keer</p>
          </aside>
        </section>
        <section>
          <h2>Thank you üôè</h2>
          <aside class="notes">
            <p>
              Volgende keer gaan we verder met adapters en gaan we dieper graven
              in het functioneel landschap. Vandaag hebben we enkel het puntje
              van de ijsberg gezien.
            </p>
            <p>Tot dan! Zal de agenda op tijd aanvullen.</p>
          </aside>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>

    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/

      Reveal.initialize({
        hash: true,
        controls: false,
        progress: false,
        slideNumber: false,
        transition: "fade",

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
