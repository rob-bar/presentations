<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Welcome to functional programming pt.4</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link
      rel="stylesheet"
      href="plugin/highlight/atom-one-dark-reasonable.css"
    />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h3>Functional Programming pt.4</h3>
          <p>
            <em><small>"The journey continues"</small></em>
          </p>
          <aside class="notes">
            Bedankt Steven voor de introductie, nog is een real life FE sync!
            Hoe lang zou dat geleden zijn? Vandaag gaan we verder met
            <strong>Functioneel Programmeren deel 4</strong>
            Voor de mensen die er vorige keer of de keren daarvoor niet bij
            waren, geen probleem. Zoals we altijd al deden gaan we beginnen met
            een kleine <strong>recap</strong>.
          </aside>
        </section>
        <section>
          <h3>Small recap</h3>
          <ul>
            <li class="fragment">FP Definition & Why? <small>pt1</small></li>
            <li class="fragment">Pure functions <small>pt1</small></li>
            <li class="fragment">Argument Adapters <small>pt2</small></li>
            <li class="fragment">Point Free <small>pt2</small></li>
            <li class="fragment">Closure <small>pt3</small></li>
          </ul>
          <aside class="notes">
            <ul>
              <li>
                Wat hebben we tot nu toe in de eerste drie delen gezien?
                <ul>
                  <li>
                    In deel 1 zijn we gaan kijken naar wat functioneel
                    programmeren nu juist is en waarom we het zouden gebruiken.
                  </li>
                  <li>
                    We hebben gekeken naar het verschil tussen
                    <strong>imperatief</strong> en
                    <strong>declaratieve</strong> code.
                    <strong>Procedurale</strong> code versus functionele code.
                  </li>
                  <li>
                    [SPACE] Daarna zijn we de pure functie gaan beginnen
                    definieren. Langzaam kwamen we tot de conclusie dat een pure
                    4 eigenschappen moest hebben.
                    <ul>
                      <li>directe inputs</li>
                      <li>directe outputs</li>
                      <li>zelfde input geeft altijd zelfde output</li>
                      <li>geen side effects</li>
                    </ul>
                  </li>
                  <li>
                    We hebben geleerd hoe we moeten omgaan met function
                    impurity, technieken zoals extraction en containing
                    impurity, samen met adapter functions gaven ons handige
                    tools om verder te gaan in deel 2
                  </li>
                  <li>
                    [SPACE] In deel 2 zagen we<strong>ARGUMENT ADAPTERS</strong
                    >: hoe gaan we functies bouwen die de vorm van een functie
                    aanpassen. We hebben bv geleerd wat
                    <strong>variotic</strong> wil zeggen.
                  </li>
                  <li>
                    We hebben gesproken over <strong>unary</strong> en
                    <strong>binary</strong> functions, we hebben gesproken over
                    <strong>Higher order functions, de term HOF</strong>.
                  </li>
                  <li>
                    Voorbeelden van higher order functions waren bijvoorbeeld de
                    Flip en Reverse functies
                  </li>
                  <li>
                    [SPACE] Bij <strong>Point Free</strong> hebben we gezien wat
                    <strong>equasional reasoning</strong> is. Point free is meer
                    een stijl van functions definieren. Waar kunnen we functies
                    definieren die <strong>dezelfde vorm</strong> hebben en hoe
                    zorgen we ervoor dat we deze functies aanropen zonder de
                    argumenten expliciet mee te geven
                  </li>
                  <li>
                    De key takeaway was dat wanneer we point free gebruiken we
                    onze <strong>code declaratiever</strong> maken, wat onze
                    leesbaarheid verhoogt.
                  </li>
                  <li>
                    [SPACE] Dan in deel 3 zijn we gaan kijken naar het grote
                    topic closure.
                  </li>
                  <li>
                    Closure is het onthouden van variabelen rond de functie ook
                    al wordt de functie ergens anders aangeroepen. Dus buiten de
                    scope van de functie.
                  </li>
                  <li>
                    We hebben gekeken naar simpele Memoization technieken en we
                    hebben geleerd wat
                    <strong>referential transparency</strong> wil zeggen. Iemand
                    nog een idee wat dat betekende? [PAUZE]
                  </li>
                  <li>
                    Referential transparency betekent een function call kan
                    vervangen worden door zijn return value zonder invloed te
                    hebben op de rest van het programma.
                  </li>
                  <li>
                    In functionele talen zoals haskel of elm referential
                    transparency is een key karakteristiek. Het is daar niet
                    mogelijk om functies te shrijven die niet pure zijn. De
                    compilers maken daar op zich dan gebruik van en replacen of
                    memoizen alles in het programma. De compiler kan dit gratis
                    doen zonder problemen.
                  </li>
                  <li>
                    Daarnaa zijn we gaan kijken naar Generalized to Specialized.
                    Hoe gaan we generieke functies gebruiken in specifiekere
                    functies.
                  </li>
                  <li>
                    We hebben geleerd dat de parameter volgorde van belang is.
                    <strong>Generiek links en specifiek rechts.</strong>
                  </li>
                  <li>
                    En dan als laatste van het derde deel hebben we gekeken naar
                    <strong>partial application</strong> en
                    <strong>curry</strong>. 2 technieken om functies van
                    generiek naar specifiek open te vouwen als het ware.
                  </li>
                  <li>
                    Mensen die 1 van de talks zouden gemist hebben, als jullie
                    willen zal ik op het einde van deze talk de links nog eens
                    doorgeven.
                  </li>
                </ul>
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Agenda</h2>
          <ul>
            <li class="fragment">Composition</li>
            <li class="fragment">Abstraction</li>
            <li class="fragment">Piping vs. composition</li>
            <li class="fragment">Associativity</li>
            <li class="fragment">Composition & Curry combined</li>
            <li class="fragment">Exercise</li>
          </ul>
          <aside class="notes">
            <ul>
              <li>TODO REWRITE</li>
              <li>
                We gaan zien dat composition associetief is zoals bv. een
                optelling.
              </li>
              <li>
                We gaan kijken naar list operations en hoe we deze kunnen
                gebruiken in een functioneel programmeren context. Dus al jullie
                favoriete methodes zoals map, filter en reduce gaan we even
                onder de loop nemen.
              </li>
              <li>
                En daarna als er nog tijd is kunnen we beginnen aan een
                oefening, en dan volgende sync zullen we kijken naar de
                oplossing.
              </li>
            </ul>
          </aside>
        </section>

        <section>
          <h2>Composition</h2>
          <aside class="notes">
            <p>
              We hebben composition al lichtjes aangeraakt toen we over point
              free aan het praten waren.
              <strong
                >Composition begint wanneer de ene functie zijn output de input
                wordt van een andere functie.</strong
              >
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|1,2,3|*">
              function minus2(x) { return x - 2; }
              function triple(x) { return x * 3; }
              function increment(x) { return x + 1; }

              // add shipping rate
              var basePrice = 43;
              var tmp = increment(4);
              tmp = triple(tmp);
              var totalCost = basePrice + minus2(tmp); // 56
            </code>
          </pre>
          <aside class="notes">
            <p>
              Hier is een voorbeeld waarbij we 3 unary functions hebben op lijn
              1 2 en 3. [SPACE]
            </p>
            <p>
              Een minus2, een triple en een increment function. En ze doen exact
              wat je zou verwachten minus2 verminderd met 2, triple
              verdrievoudigd het, en increment telt er 1tje bij op.
            </p>
            <p>
              Op lijn 7 gaan we increment met 4 aanroepen dat steken we in een
              tmp variable en dan gaan we die tmp variable in de triple functie
              doorgeven daarna gaan we tmp gebruike op lijn 9 om aan minus2 te
              geven zodanig dat we de shipping rate kunnen toevoegen aan de
              basePrice ook op lijn 9.
            </p>
            <p>
              Met dit scenario gaan we gedurende de volgende slides het idee van
              composition duidelijk maken. Wat het belangrijkste is om mee te
              nemen hier is dat je gemakkelijk kan spotten wanneer de ene
              function call zijn output kan verwezen worden naar de andere.
            </p>
            <p>
              Meestal gaan we het in een soort tussen variable steken zoals hier
              in het voorbeeld met de tmp variable, en soms zie je ze letterlijk
              genest waarbij de ene functie in de andere wordt aangeroepn. Maar
              meestal zie je tussenvariabelen, ook voor de leesbaarheid te
              verhogen. We willen op het punt geraken waar we kunnen zeggen,
              aha! dit is een compositie van functies.
            </p>
            <p>
              Om compositie te illustreren gaan in de volgende slides even
              metaforisch verder gaan.
            </p>
          </aside>
        </section>

        <section>
          <h2>Abstraction</h2>
          <aside class="notes">
            <p>
              Maar voor alleer we verder gaan met de metafoor wil ik het even
              hebben abstraction. Wie heeft al van de term abstraction gehoord?
              [PAUZE]
            </p>
            <p>
              Abstraction is een term dat vaak wordt rondgegooid in
              programmeren. Maar niemand kan echt zeggen wat de definitie ervan
              is. Het heeft veel betekenissen op verschillende plaatsen.
            </p>
            <p>
              Maar we spreken hier over het origneel idee achter abstraction.
              Bij abstraction hebben we altijd 2 stukken code die met elkaar te
              maken hebben. Met elkaar verweven.
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|7,8,9">
              function minus2(x) { return x - 2; }
              function triple(x) { return x * 3; }
              function increment(x) { return x + 1; }

              // add shipping rate
              var basePrice = 43;
              var tmp = increment(4);
              tmp = triple(tmp);
              var totalCost = basePrice + minus2(tmp); // 56
            </code>
          </pre>
          <aside class="notes">
            <p>
              [SPACE] We kunnen hier naar lijn 7, 8 en 9 kijken en zeggen dat er
              2 verschillende dingen gebeuren. Het eerste is we calculeren een
              shippingrate, het tweede is dat we het dan optellen bij de
              basePrice om een total cost te berekenen.
            </p>
            <p>
              Dit zijn 2 verschillende bezorgdheden maar in dit stuk code zijn
              ze met elkaar verwoven.
            </p>
            <p>
              Het originele idee achter abstraction is dat we deze 2 dingen gaan
              scheiden van elkaar en er semantic boundary tussenin plaatsen. Zo
              kunnen we niet iets verbergen, dat is wat velen denken dat
              abstractie is. Het gaat niet om verbergen, het gaat om scheiden
              van elkaar.
            </p>
            <p>
              Zet deze twee dingen apart zodat ik naar het ene kan kijken en het
              begrijpen en daarna naar het andere kan kijken en het begrijpen.
              Zonder te moeten denken aan het andere deel dat gescheiden is.
            </p>
            <p>
              Hoe zouden we lijn 7, 8 en 9 dan abstraheren? Niet verbergen, maar
              scheiden van elkaar. Hou de mogelijke oplossing even in u
              achterhoofd terwijl we doorgaan met de metafoor...
            </p>
          </aside>
        </section>

        <section>
          <img src="img/candy1.png" alt="candy factory" width="800" />
          <aside class="notes">
            <p>
              Ok, we doen efkes alsof we een ingenieur zijn in een chocolade
              fabriek. En in de chocolade fabriek hebben we hier geweldig
              getekend process waar we van de ene machien naar de andere gaan
              via de loopbanden tussenin en elk machien gaat telkens een taak
              voor zich nemen en iets doen met elk stuk chocolade.
            </p>
            <p>
              Eerst hebben we de gesmolte chocolade die dan in grote stukken
              wordt gegoten, dan hebben we een machine die die er een bedrukking
              op doet, dan hebben we een machine die de verpakking voor zich
              neemt, etc. etc.
            </p>
            <p>
              En alles gaat goed, want jij bent de ingeneieur die
              verantwoordelijk is voor de machines.
            </p>
            <p>
              Maar op een dag komt de CEO bij u en zegt: "Ge zijt heel goed
              bezig en alles draait prima, maar we hebben een klein probleemke
              dat we willen oplossen, kun jij als ingenieur daar is naar
              kijken?"
            </p>
            <p>
              Onze concurentie produceerd meer chocolade dan wij doen. Ze
              produceren 2 tot 3 keer meer en we moeten evenveel kunnen
              produceren. Dus wat de CEO zegt is: "kun je meer chocolade
              maken?""
            </p>
            <p>
              De band versnellen kan niet, dus we zouden meer machines moeten
              hebben, maar het probleem is dat er geen plaats meer is in de
              fabriek.
            </p>
            <p>
              Dus jij als ingenieur slaapt er een nachtje over en denkt na hoe
              we dit probleem kunnen oplossen. [PAUZE] Maar we drukken even op
              pauze hier en gaan terug naar ons code voorbeeld.
            </p>
            <p>
              Herriner u al de tmp variables in de code die we gebruikten als
              doorgeefluik? Die tmp variables maken een beetje een rommelke van
              de code en ze zijn niet echt waardevol voor ons. Dus we denken.
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|7,8,9">
              function minus2(x) { return x - 2; }
              function triple(x) { return x * 3; }
              function increment(x) { return x + 1; }

              // add shipping rate
              var basePrice = 43;
              var totalCost = 
                basePrice + minus2(triple(increment(4); // 56
            </code>
          </pre>
          <aside class="notes">
            <p>
              We doen de temp varables weg en we zetten elke functie gewoon in
              de volgende functie.
            </p>
            <p>
              We roepen increment 4 aan geven dat door aan trippe en dan aan
              minus2 en dan BAM we hebben een shippingrate.
            </p>
            <p>Iemand dit al gedaan in zijn programma? [RAISE OF HANDS]</p>
            <p>
              Dus of je het wist of niet. Je was compositie aan het gebruiken.
              Dat is een compositie, de output van de ene functie gebruiken als
              input voor de andere.
            </p>
            <p>
              We hebben die lelijke temp variables weggesmeten en we hebben
              plaats gemaakt. En de code is opgekuist.
            </p>
            <p>
              Laten we teruggaan naar de chocoladefabriek, jij als ingenieur
              bent even aan het nadenken en denkt: "ik denk dat het probleem de
              loopbanden zijn, ze nemen teveel plaats in.", Opeens krijg je het
              briljante idee en je denkt: "wat als we de loopbanden gewoon eruit
              nemen en we zetten de machines op elkaar.
            </p>
            <p></p>
          </aside>
        </section>

        <section>
          <img src="img/candy2.png" alt="candy factory" width="800" />
          <aside class="notes">
            <p>
              Het eerste machien bovenaan gieten we de chocolade in, daarna
              komen de grote bloken eruit, dan kleinere stukjes en dan de
              verpakking, allemaal van boven naar beneden.
            </p>
            <p>
              Problem solved want nu kan ik veel meer machines plaatsen in de
              chocoladefabriek. Al de overhead van de loopbanden is weg, al die
              temp vars.
            </p>
            <p>
              Iedereen is happy in het bedrijf, je krijgt een schouderklopke van
              de baas en dingen gaan goed, voor ongeveer 6 maanden.
            </p>
            <p>
              Na 6 maanden komt de baas bij jou en zegt: "We hebben nu een
              probleem, we vinden het geweldig dat we meer chocolade kunnen
              produceren, maar de werkmannen klagen dat de machines te complex
              aan elkaar hangen, teveel bedrading en mogelijks problemen tijdens
              de bediening door het teveel aan buttons en te complexiteit per
              machien."
            </p>
            <p>
              Is er een manier waarbij we met 1 machine alles kunnen doen? Dus
              bovenaan de chocolade ingieten en dan onderaan komt de verpakking
              eruit.
            </p>
            <p>
              Je denkt bij jezelf, ook al zou ik dat kunnen doen dan zou het nog
              steeds moeiljk zijn om die individuele stappen te onderhouden. Er
              moet een bepaalde manier zijn om daar nog toegang toe te
              verkrijgen.
            </p>
            <p>We hebben hetzelfde probleem in onze codebase.</p>
            <p>
              We hebben de plaats waar we de shippingRate berekenen en we hebben
              de plaats waar we die toevoegen aan de totalCost. Maar ze zijn nog
              verwoven met elkaar. Dus wij als programmeurs denken, simpelweg
              gewoon een functie maken voor de shippingRate te calculeren.
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|11|7,11">
              function minus2(x) { return x - 2; }
              function triple(x) { return x * 3; }
              function increment(x) { return x + 1; }

              // add shipping rate
              function shippingRate (x) {
                return minus2(triple(increment(x)));
              }

              var basePrice = 43;
              var totalCost = basePrice + shippingRate(4); // 56
            </code>
          </pre>
          <aside class="notes">
            <p>
              We maken de functie die exact dat werk doet: minus2, triple en
              increment, ze neemt de waarde in. En kijk nu naar lijn 11 [SPACE]
            </p>
            <p>
              Lijn 11 is veel netter omdat op lijn 11 nu de twee bezorgdheden
              gescheiden zijn.
            </p>
            <p>
              [SPACE] Lijn 7 is waar we zeggen hoe we de shippingRate
              samenstellen. En lijn 11 is waar we zeggen wat ermee moet
              gebeuren.
            </p>
            <p>Dit is een voorbeeld van abstraction.</p>
            <p>
              En de semantische grens die we hebben opgelegd, is de function
              naam.[PAUZE]
            </p>
            <p>
              Dus terug naar de chocoladefabriek. We hebben er efkes over
              nagedacht en we vonden de perfecte oplossing. We moeten ons geen
              zorgen maken over de machines, het enige wat we moeten doen is ze
              omkaderen met een mooie doos rond heel de setup.[SPACE]
            </p>
          </aside>
        </section>

        <section>
          <img src="img/candy3.png" alt="candy factory" width="800" />
          <aside class="notes">
            <p>
              Maak gewoon 1 grote doos die rond de kleinere interne machines
              zit. Inclusief een mooi acces panel voor de aan en uitknop en voor
              wanneer jij de ingenieur problemen moet oplossen.
            </p>
            <p>
              Dit is het beste van twee werelden want de werkmannen kunnen
              gewoon de aan en uitknop bedienen. Die geven enkel om de input en
              output, maar jij de ingeneieur weet nog steeds de ins en outs van
              de interne werking.
            </p>
            <p>
              Wat heb ik gedaan? Ik heb een abstractie gemaakt van mijn
              compositie, ik heb het gewrapped in een functie. Dat is wat deze
              doos is conceptueel.
            </p>
            <p>
              We implementeren deze oplossing, en de baas komt terug en zegt
              enthousiast:"oh de werkmannen vinden het geweldig. Ze kunnen nu
              gewoon binnenkomen en enkel op de knop drukken en andere
              ingenieurs kunnen het toeganspaneel opendoen wanneer nodig etc
              etc. Goed gewerkt, geweldige oplossing"
            </p>
            <p>
              6 maanden gaan voorbij en alles gaat goed, en de baas komt terug
              naar jou en zegt: "Ik heb nog een probleem dat je voor mij moet
              oplossen." (dit is een beetje een neady baas he, veel problemen
              maar zo behouden we wel ons werk ;) )
            </p>
            <p>
              Het probleem is dat onze concurenten capabel zijn van
              verschillende soorten chocolade te verzinnen op een dagelijkse
              basis. De ene dag maken ze melkchocolade, de andere dag gigantise
              verpakkingen, de andere dag maken ze witte, etc etc. Het is
              fascinerend hoe ze zo snel kunnen verschillend soorten chocolade
              snoepjes kunnen maken.
            </p>
            <p>
              Wij kunnen ze niet bijhouden, zij experimenteren constant en wij
              blijven onze enige soort en onze enige snoepjes maken. En we
              hebben geprobeerd, we hebben ge-experimenteerd maar het is te
              traag en te log om al die dozen te maken met verschillende
              machienen geconfigureerd binnenin. "Kunnen we dit volgens jouw
              meer efficient gaan doen?"
            </p>
            <p>
              Zonder het te bessefen heeft de baas niet door dat hij jou bijna
              iets onmogelijks vraagt. Eigenlijk vraagt hij jou: "Kunnen we een
              machien maken dat machienen maakt?" HEHE
            </p>
            <p>
              Een machine dat machines neemt als inputs, en een machine bouwt
              als output? Vind het maar uit! [PAUZE] Dit is een gigantische
              breinbreker en dat gaat wel een tijdje duren om uit te vinden.
              Maar we gaan eraan werken. Laat ons terug naar de code switchen.
            </p>
            <p>
              We waren aan het denken aan die shippingRate calculatie en het
              gaat prima zo, maar iemand in het bedrijf zegt:"We hebben
              eigenlijk verschillende shipping rate's, we hebben international
              shippinRate, we hebben domestic shippingRate, we hebben overnight
              shippingRate, etc. ect
            </p>
            <p>
              En overal waar we die functies definieren in onze code, wordt het
              zo te rommelig. Kunnen we makkeijker shippingRate functions
              definieren? Dus jij als programmeur denkt, wel sure! Er is
              misschien een patroon dat je kan gebruiken.
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*">
              function composeThree(fn3, fn2, fn1) {
                return function composed(v) {
                  return fn3(fn2(fn1(v)));
                }
              }
            </code>
          </pre>

          <aside class="notes">
            <p>
              Dus we bedenken deze composeThree function: ze neemt 3 functies,
              fn3, fn2 en fn1. Ik leg later uit waarom die volgorde. Het neemt
              die 3 functions en het produceerd een nieuwe functie welke die 3
              functies opeenvolgend aanroept.
            </p>
            <p>
              De eerste krijgt de input waarde output daarvan gaat naar de tweed
              en daarna gaat de output naar de derde om zo uiteindelijk terug te
              geven.
            </p>
            <p>
              En nu kunnen we opmerken dat we zoveel shippingRates kunnen maken
              als we willen [SPACE]
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|6,7">
              function minus2(x) { return x - 2; }
              function triple(x) { return x * 3; }
              function increment(x) { return x + 1; }

              // add shipping rate
              var shippingRate =
                composeThree(minus2, triple, increment);

              var basePrice = 43;
              var totalCost = basePrice + shippingRate(4); // 56
            </code>
          </pre>

          <aside class="notes">
            <p>
              We kunnen de standaard shippingrate er zo laten uitzien als in het
              voorbeeld. Maar later kunnen we zeggen dat de
              internationalShippingRate een andere bewerking heeft: een minus4
              of een quadruple, etc etc.
            </p>
            <p>
              We geven gewoon verschillende functions en we krijgen een andere
              shippingRate als resultaat.[PAUZE]
            </p>
            <p>
              Kunnen jullie zien waarom de definitie van shippingRate op lijn 5
              en 6 niet allen point free is maar ook meer declaratief is
              geschreven.
            </p>
            <p>
              Het zegt tegen iemand dat weet wat compositie is: "Dit gaat in de
              volgorde van rechts naar links uitvoeren van increment naar triple
              naar minus2 en uiteindelijk geeft het de eindwaarde terug"
            </p>
            <p>
              Functioneel programeurs weten dit. En wat we hier zien is dat
              compositie gelijk is aan <strong>declaratieve data flow</strong>.
            </p>
            <p>
              Het is de flow van de data doorheen een reeks operaties die eerder
              declaratief is gedefineerd dan imperatief.
            </p>
            <p>
              Dit is waarom het zo kritiek is: uw programma betekenen niets
              zonder data flow. Dat is net het hele punt van een app of
              programma. Data binnenkrijgen er iets mee doen en het teruggeven.
              Het is een serie van state transitions.
            </p>
            <p>
              En de functioneel programeur weet: als dat de essentie is van ons
              programma, dan moeten we de data flow zo declaratief mogelijk
              maken. Duidelijk en expliciet ipv verborgen en impliciet.
            </p>
            <p>
              Sommige apps zijn zo complex dat de functions de data flow niet
              aantonen. De ene functie roept andere functies aan doorheen heel
              de codebase, van functie naar functie "all over the place". EN het
              is geen gemakkelijke opgave om de dataflow te volgen, misschien
              wel de moeilijkste opgave van allemaal.
            </p>
            <p>
              Hoe gemakkelijk is het om de data flow op lijn 7 te volgen?
              <br />Het Zo simpel als van rechts naar links te lezen.
            </p>
            <p>
              Composition is supperkritiek onderwerp in functioneel programmeren
              want het hele punt van een programma is de data flow.
            </p>
            <p>
              Die composeThree die we net hebben uitgevonden voor deze discutie
              te voeren is enkel een voorbeeld. Er is een meer generieke functie
              compose die oneindig veel functies neemt als argument. Ga gerust
              is kijken naar de docs van Rambda of lodash. Het zit in elke
              favoriete FP library die we kennen.
            </p>
            <p>
              Laat ons nog 1 keer naar de chocolade gaan waar jij als ingenieur
              hard gewerkt hebt en je hebt een groote onthulling aan de baas te
              doen en je zegt: "Ik heb het probleem opgelost"
            </p>
            <p>
              Ik realiseerde me dat alle machines dat we gebruiken standaard
              input en output valves hebben. De bedrading en de switches zijn
              ook gestandaardiseerd. Dus wat ik bessefte is dat we een machien
              kunnen maken die machines bouwt.
            </p>
          </aside>
        </section>

        <section>
          <img src="img/candy4.png" alt="candy factory" width="800" />
          <aside class="notes">
            <p>
              Laat er eender welke gestandaardiseerde machine in vallen en wat
              eruit komt is een mooie unieke machines met alle toeters en
              bellen. On of switches, bedieningspaneel, alle toeters en bellen.
            </p>
            <p>
              Ik weet dat het een beetje een uitrekking is van de metafoor, maar
              hopelijk zie je de connectie met de composeThree utility function.
            </p>
            <p>
              De composeThree zijnde een Higher order function, dat een machines
              is die machines maakt. Dat is waar compositie over gaat.
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|5|6|8,9|*">
              function minus2(x) { return x - 2; }
              function triple(x) { return x * 3; }
              function increment(x) { return x + 1; }

              var f = composeThree(minus2, triple, increment);
              var p = composeThree(increment, triple, minus2);

              f(4); // 13
              p(4); // 7
            </code>
          </pre>

          <aside class="notes">
            <p>
              Dus we kunnen diezelfde composeThree utility nemen en meerdere
              keren gebruiken.
            </p>
            <p>
              Als ik het aanroep met minus2, triple en increment dan maken we de
              f composition op lijn 5 [SPACE] dan gaat die eerst incrementeren
              dan verdrievoudigen en dan 2 verminderen.
            </p>
            <p>
              En als ik die composeThree aanroep met argumenten in de omgekeerde
              volgorde op lijn 6 [SPACE] dan hebben we een andere functie welke
              een ander resultaat oplevert.
            </p>
            <p>
              [SPACE] Dezelfde input 4 gegeven aan f produceert 13 waarbij de
              input 4 gegeven aan de g functie 7 produceert.
            </p>
            <p>
              4 verhogen met 1, maal 3 en dan verminderen met 2 is 13. <br />
              4 verminderen met 2, maal 3 en dan verhogen met 1 is 7.
            </p>
          </aside>
        </section>

        <section>
          <h4>Compose: right-to-left</h4>
          <h4>Pipe: left-to-right</h4>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|5,6,11">
              function minus2(x) { return x - 2; }
              function triple(x) { return x * 3; }
              function increment(x) { return x + 1; }

              var f = composeThree(minus2, triple, increment);
              var p = composeThree(increment, triple, minus2);

              f(4); // 13
              p(4); // 7

              var g = pipeThree(minus2, triple, increment);
            </code>
          </pre>

          <aside class="notes">
            <p>
              En wat als ik ze in de omgekeerde volgorde wil definieren?[SPACE]
            </p>
            <p>
              Je kan u voorstellen als we een composeThree hebben gemaakt
              kunnenw we ook een pipeThree function gaan maken waar we de
              argumenten omgekeerd doorgeven. Kijk vooral naar het verschil
              tussen lijn 5, 6 en 11.
            </p>
            <p>
              Lijn 11 heeft de argumenten in dezelfde volgorde dan lijn 5, maar
              het resultaat is hetzelfde als lijn 6, hetzelfde als de p
              function.
            </p>
            <p>
              kleine annekdote: Maar waarom is dit zo? Het ligt eigenlijk aan de
              compiler en de engels taal waarin wij de code lezen als mensen.
              [PAUZE] Een argument moet volgens de javascript compiler eerst
              berekend zijn voor alleer de functie aangeroepen kan worden.Als
              het arument een functie is dan moet de functie eerst worden
              aangeroepen om berekend te zijn. [PAUZE] Dus op zich is het niet
              right to left maar eerder inner to outer.
            </p>
            <p>
              Soms is het handiger voor ons om van links naar rechts te denken
              en te lezen, dan gebruiken we de pipe function. Zoals ik in talk 3
              zei: bij partial application en currying. Eerst gaan meer mensen
              beginnen met partial application en dan worden ze overtuigd om
              currying te gebruiken. Hetzelfde geld hier: een onervaren
              functioneel programeur zal misschien eerst de pipe function
              gebruiken omdat het voor hem gemakkelijker leest. Hoe meer je
              functional programming toepast, hoe meer je gaat realiseren dat
              compose in de meeste situatie veel logischer aanvoelt.
            </p>
          </aside>
        </section>

        <section>
          <h4>Associativity</h4>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*">
              function minus2(x) { return x - 2; }
              function triple(x) { return x * 3; }
              function increment(x) { return x + 1; }

              function composeTwo(fn2, fn1) {
                return function composed(v) {
                  return fn2(fn1(v));
                }
              }
            </code>
          </pre>

          <aside class="notes">
            <p>
              Associativiteit, we kennen het misschien nog van in de les
              wiskunde. Of vanop de hoge school. Als ik zeg 1 plus 2 plus 3. Dan
              kan ik zeggen dat de plus operator associatief omdat ik de
              getallen van plaats kan veranderen of ik kan 2+3 eerst doen en
              daarna +1 of ik kan 1+2 optellen en daarna +3 en het resultaat
              blijft hetzelfde.
            </p>
            <p>Dat is een karakteristiek van bepaalde wiskundige opperaties.</p>
            <p>
              De reden waarom we het hier bespreken is omdat composition ook
              associatief is.
            </p>
            <p>
              Wat wil zeggen als ik een lijst van functies heb die ik wil
              composen dan kan ik de volgorde van de functies veranderen of
              eender welke groepering kiezen en het resultaat blijft hetzelfde.
            </p>
            <p>
              Dus hier hebben we een composeTwo functie die enkel 2 functies
              behandeld, het behandeld er geen 3 of geen 20. Simpelweg 2.
            </p>
          </aside>
        </section>

        <section>
          <h4>Associativity</h4>
          <pre data-id="code-animation" style="font-size: 0.9rem">
            <code class="language-js" data-trim data-line-numbers="*|12|11-14|16-19">
              function minus2(x) { return x - 2; }
              function triple(x) { return x * 3; }
              function increment(x) { return x + 1; }

              function composeTwo(fn2, fn1) {
                return function composed(v) {
                  return fn2(fn1(v));
                }
              }

              var f = composeTwo(
                composeTwo(minus2, triple),
                increment
              );

              var p = composeTwo(
                minus2,
                composeTwo(triple, increment)
              );

              f(4); // 13
              p(4); // 13
            </code>
          </pre>

          <aside class="notes">
            <p>
              Als we kijken naar dit voorbeeld dan kunnen we zeggen op lijn 12
              composeTwo van minus2 en triple. Die composition is samengesteld
              met increment, van lijn 1 tot 14.
            </p>
            <p>
              We hebben nog steeds dezelfde right-to-left volgorde: increment
              dan triple dan minus2.
            </p>
            <p>
              Dan hebben we de p functie: welkde op zich erst composeTwo doet
              van triple en increment op lijn 18 en daarna minus2 samensteld via
              compose op lijn 17. Nog streeds dezelfde volgorde: increment,
              triple, minus2.
            </p>
            <p>
              De f en p functies zien er verschillend uit maar ze hebben
              hetzelfde resultaat omdat composition associatief is.
            </p>
            <p>
              Dat is eigenlijk supernuttig voor ons als functioneel
              programmeurs. Dit wil zeggen dat we curry en partial applications
              kunnen uitvoeren op onze compositions.
            </p>
            <p>
              We moet niet weten welke functies gaan deelnemen aan een
              compositie op voorhand. We zouden de compose utility kunnen
              currien waarbij we 2 functies nu doorgeven en dan erna kunnen we
              het nog met iets anders composen. En zo kunnen we doorgaan, en wat
              doen we wanneer we dat telkens doen?
            </p>
            <p>We creeren een specifiekere functie elke keer.</p>
            <p>
              Dus de associatieve eigenschap van composition klinkt een beetje
              genuanceerd hier maar is extreem critiek om het zo nuttig te
              maken.
            </p>
          </aside>
        </section>

        <section>
          <h2>Currying revisited</h2>
          <aside class="notes">
            <p>
              Laat ons is kijken hoe currying zo nuttig kan zijn gecombineerd
              met composition.
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|5">
              function sum(x, y) { return x + y; }
              function triple(x) { return x * 3; }
              function divBy(y, x) { return x / y; }

              divBy( 2, triple( sum(3, 5) ) ); // 12
            </code>
          </pre>

          <aside class="notes">
            <p>
              We hebben hier een sum functie, een triple functie en een divBy
              functie.
            </p>
            <p>2 van deze functies zijn binary en 1tje is unary.</p>
            <p>De sum en de divBy zijn binary en de triple is unary.</p>
            <p>
              Ik zou graag een composition van deze maken. Maar we zagen in de
              vorige voorbeelden dat alle functies in compositions unary
              functions waren.
            </p>
            <p>
              Waarom zouden we enkel unary functions coposen? Kan iemand even
              raden? Kan iemand mij dat zeggen? [WACHT OP ANTWWORD]
            </p>
            <p>
              Bekijk het even zo, wat zou er nodig zijn om de output van triple
              de input van de sum function te laten zijn? [WACHT]
            </p>
            <p>
              Je zou dan twee outputs nodig hebben inderdaad. Want sum verwacht
              2 inputs. Omdat functies maar enkel 1 output kunnen reproduceren
              is er maar 1 natuurlijke manier om ze te composen. Ze moeten
              allemaal unary zijn. Single input, Single output, single input,
              single output, etc.
            </p>
            <p>
              Dus er is een reden type signature wise, waarom het handiger is om
              unary functions te gaan samenstellen.
            </p>
            <p>
              Hier op lijn 5 [SPACE] hebben we een composition, maar wel een
              manuele. Hoe zouden we die kunnen uitdrukken met een call naar de
              compose utility function?
            </p>
            <p>
              Ik heb een sum die 2 waarden aanvaard wat niet werkt en ik heb een
              divBy die 2 waardes aanneemt wat ook niet werkt.
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|11-13">
              function sum(x, y) { return x + y; }
              function triple(x) { return x * 3; }
              function divBy(y, x) { return x / y; }

              divBy( 2, triple( sum(3, 5) ) ); // 12

              sum = curry(2, sum);
              divBy = curry(2, divBy);

              composeThree(
                divBy(2),
                triple,
                sum(3)
              )(5); // 12
            </code>
          </pre>

          <aside class="notes">
            <p>
              Wat als we de sum en divBy functions currien? En dan die functies
              doorgeven op lijn 11 en 13? [SPACE].
            </p>
            <p>DivBy en sum op lijn 11 en 13 zijn nu unary functions.</p>
            <p>
              Dus herriner u de vorige talk, met currying konden we functies
              gaan hervormen van binary naar unary functions en hier kunnen we
              die functies gaan samen composen.
            </p>
          </aside>
        </section>

        <section>
          <h2>Point-free revisited</h2>
          <pre data-id="code-animation">
            <code class="language-js" data-trim data-line-numbers="*|1,2">
              var mod2 = mod(2); // curried mod function
              var eq1 = eq(1); // curried eq function

              // function isOdd(x) {
              //   return x % 2 === 1;
              // }

              function isOdd(x) {
                return eq1(mod2(x));
              }
            </code>
          </pre>

          <aside class="notes">
            <p>
              Laten we nog even praten over point-free programmeer stijl. Nu dat
              we composition en curry samen hebben gezien. kunnen we isOdd van
              vroeger in de cursus nog is opnieuw gaan definieren. Herriner u
              nog isOdd? [SPACE]
            </p>
            <p>
              Op Lijnen 1 en 2 zien we curry versies van de functies modulo en
              equal.
            </p>
            <p>
              Dus als we de isOdd functie willen definieren point free style dan
              nemen we nu een compose utility.
            </p>
          </aside>
        </section>

        <section>
          <pre data-id="code-animation" style="font-size: 0.9rem">
            <code class="language-js" class="small" data-trim data-line-numbers="12-16|18|19|*">
              var mod2 = mod(2); 
              var eq1 = eq(1); 

              // function isOdd(x) {
              //   return x % 2 === 1;
              // }

              function isOdd(x) {
                return eq1(mod2(x));
              }

              function composeTwo(fn2, fn1) {
                return function composed(v) {
                  return fn2(fn1(v));
                }
              }

              var isOdd = composeTwo(eq1, mod2);
              var isOdd = composeTwo(eq(1), mod(2));
            </code>
          </pre>

          <aside class="notes">
            <p>genaamd composeTwo hier te zien van lijn 12 tot lijn 16</p>
            <p>
              We nemen een composeTwo utility en we geven hier de eq1 en mod2
              unary functions aan mee op lijn 18[SPACE] en dan op lijn 19 kunnen
              we hetzelfde doen met behulp van equasional reasoning. Lijn 18 en
              19 zijn infeite hetzelfde.
            </p>
            <p>
              Anders gezegd we hadden 2 binary functions die we wouden composen.
              We kunnen geen binary functions composen dus we hebben ze
              omgevormd met curry naar unary functions, we gaven ze telkens 1
              input en dan hebben we dan die geproduceerde unary functions
              gecombineerd met een composeTwo utility.
            </p>
          </aside>
        </section>

        <section>
          <h3>
            <a
              href="https://gitlab.mediahuisgroup.com/robbie.bardijn/functional-programming/-/tree/master/composition"
              target="_blank"
              >Composition Exercise</a
            >
          </h3>
          <aside class="notes">
            <p>
              Alright, dat was een hele boterham, en voor de mensen die nog
              onzeker zijn over topics van de vorige talks, bekijk zeker nog is
              die recordings. Ik weet nog in talk 3 hadden we op het einde een
              curried function in een map functie als argument gegeven om als
              voorbeeld aan te tonen dat curry heel handig kan zijn wanneer we
              die combineren met de map utiity van het Array prototype.
            </p>
            <p>
              Deze oefening is zeker minder uitdagend dan de vorige van closure.
            </p>
            <p>
              In deze oefening gaan we 2 generieke functies schrijven genaamd
              pipe en compose. Belangrijk is hier dus dat ze een oneindig aantal
              argumenten kunnen hebben beide.
            </p>
            <p>
              In de setup zie je een aantal functions die voorgedefinieerd zijn
              zoals increment en decrement etc, van lijn 3 tot 6. En je ziet dat
              je op lijn 8 en 9 de implementaties moet doen van de pipe en
              compose functies.
            </p>
            <p>
              Ze werkt weer op dezelfde mannier als voorgaande oefeningen, je
              moet de tests stap voor stap doen slagen die onderaan staan.
            </p>
            <p>
              Nog een laatste hint, als je een van de twee functies hebt
              gemaakt, dan kun je de andere functie maken op basis van de eerste
              functie die je gemaakt hebt.
            </p>
            <p>
              We hebben de closure oefening nog niet samen gedaan, we zullen
              anders volgende keer dat we samen zitten. de twee oefeningen
              ineens oplossen.
            </p>
          </aside>
        </section>

        <section>
          <h2>Thank you üôè</h2>
          <aside class="notes">
            <p>
              Volgende talk gaan we kijken naar immutability vanuit een
              functioneel perspectief. We hadden in het verleden al een talk
              gekregen van Steven ivm. de structuredClone web api. immutability
              is een breed topic en de reden waarom het belangrijk is is bij
              iedereen misschien nog niet gekend. Tot dan! en!
            </p>
            <p>Bedankt voor jullie aandacht.</p>
          </aside>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>

    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>

    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/

      Reveal.initialize({
        hash: true,
        controls: false,
        progress: false,
        slideNumber: false,
        transition: "fade",

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
